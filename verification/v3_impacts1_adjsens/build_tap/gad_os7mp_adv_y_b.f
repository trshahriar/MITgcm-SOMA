C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 20 Jun 2024 17:41
C
C  Differentiation of gad_os7mp_adv_y in reverse (adjoint) mode:
C   gradient     of useful results: vfld q vt vtrans
C   with respect to varying inputs: vfld q vt vtrans
C
C
C
C
C
C
C
C
C
C
C
CBOP
C !ROUTINE: GAD_OPTIONS.h
C
C !INTERFACE:
C #include "GAD_OPTIONS.h"
C
C !DESCRIPTION:
C Contains CPP macros/flags for controlling optional features of package.
CEOP
C
C CPP options file for GAD (Generic Advection Diffusion) package
C Use this file for selecting options within the GAD package
C
C
C
C
C
C
C
C
CBOP
C !ROUTINE: CPP_OPTIONS.h
C !INTERFACE:
C #include "CPP_OPTIONS.h"
C
C !DESCRIPTION:
C *==================================================================*
C | main CPP options file for the model:
C | Control which optional features to compile in model/src code.
C *==================================================================*
CEOP
C
C CPP flags controlling particular source code features
C
C-- Forcing code options:
C
C o Shortwave heating as extra term in external_forcing.F
C Note: this should be a run-time option
C
C o Include/exclude Geothermal Heat Flux at the bottom of the ocean
C
C o Allow to account for heating due to friction (and momentum dissipation)
C
C o Allow mass source or sink of Fluid in the interior
C   (3-D generalisation of oceanic real-fresh water flux)
C
C o Include pressure loading code
C
C o Include/exclude balancing surface forcing fluxes code
C
C o Include/exclude balancing surface forcing relaxation code
C
C o Include/exclude checking for negative salinity
C
C-- Options to discard parts of the main code:
C
C o Exclude/allow external forcing-fields load
C   this allows to read & do simple linear time interpolation of oceanic
C   forcing fields, if no specific pkg (e.g., EXF) is used to compute them.
C
C o Include/exclude phi_hyd calculation code
C
C-- Vertical mixing code options:
C
C o Include/exclude call to S/R CONVECT
C
C o Include/exclude call to S/R CALC_DIFFUSIVITY
C
C o Allow full 3D specification of vertical diffusivity
C
C o Allow latitudinally varying BryanLewis79 vertical diffusivity
C
C o Exclude/allow partial-cell effect (physical or enhanced) in vertical mixing
C   this allows to account for partial-cell in vertical viscosity and diffusion,
C   either from grid-spacing reduction effect or as artificially enhanced mixing
C   near surface & bottom for too thin grid-cell
C
C-- Time-stepping code options:
C
C o Include/exclude combined Surf.Pressure and Drag Implicit solver code
C
C o Include/exclude Implicit vertical advection code
C
C o Include/exclude AdamsBashforth-3rd-Order code
C
C-- Model formulation options:
C
C o Allow/exclude "Exact Convervation" of fluid in Free-Surface formulation
C   that ensures that d/dt(eta) is exactly equal to - Div.Transport
C
C o Allow the use of Non-Linear Free-Surface formulation
C   this implies that grid-cell thickness (hFactors) varies with time
C
C o Include/exclude nonHydrostatic code
C
C o Include/exclude GM-like eddy stress in momentum code
C
C-- Algorithm options:
C
C o Use Non Self-Adjoint (NSA) conjugate-gradient solver
C
C o Include/exclude code for single reduction Conjugate-Gradient solver
C
C o Choices for implicit solver routines solve_*diagonal.F
C   The following has low memory footprint, but not suitable for AD
C   The following one suitable for AD but does not vectorize
C
C-- Retired code options:
C
C o Use LONG.bin, LATG.bin, etc., initialization for ini_curviliear_grid.F
C   Default is to use "new" grid files (OLD_GRID_IO undef) but OLD_GRID_IO
C   is still useful with, e.g., single-domain curvilinear configurations.
C
C-- Other option files:
C
C o Execution environment support options
C
CBOP
C     !ROUTINE: CPP_EEOPTIONS.h
C     !INTERFACE:
C     include "CPP_EEOPTIONS.h"
C
C     !DESCRIPTION:
C     *==========================================================*
C     | CPP\_EEOPTIONS.h                                         |
C     *==========================================================*
C     | C preprocessor "execution environment" supporting        |
C     | flags. Use this file to set flags controlling the        |
C     | execution environment in which a model runs - as opposed |
C     | to the dynamical problem the model solves.               |
C     | Note: Many options are implemented with both compile time|
C     |       and run-time switches. This allows options to be   |
C     |       removed altogether, made optional at run-time or   |
C     |       to be permanently enabled. This convention helps   |
C     |       with the data-dependence analysis performed by the |
C     |       adjoint model compiler. This data dependency       |
C     |       analysis can be upset by runtime switches that it  |
C     |       is unable to recoginise as being fixed for the     |
C     |       duration of an integration.                        |
C     |       A reasonable way to use these flags is to          |
C     |       set all options as selectable at runtime but then  |
C     |       once an experimental configuration has been        |
C     |       identified, rebuild the code with the appropriate  |
C     |       options set at compile time.                       |
C     *==========================================================*
CEOP
C
C     In general the following convention applies:
C     ALLOW  - indicates an feature will be included but it may
C     CAN      have a run-time flag to allow it to be switched
C              on and off.
C              If ALLOW or CAN directives are "undef'd" this generally
C              means that the feature will not be available i.e. it
C              will not be included in the compiled code and so no
C              run-time option to use the feature will be available.
C
C     ALWAYS - indicates the choice will be fixed at compile time
C              so no run-time option will be present
C
C=== Macro related options ===
C--   Control storage of floating point operands
C     On many systems it improves performance only to use
C     8-byte precision for time stepped variables.
C     Constant in time terms ( geometric factors etc.. )
C     can use 4-byte precision, reducing memory utilisation and
C     boosting performance because of a smaller working set size.
C     However, on vector CRAY systems this degrades performance.
C     Enable to switch REAL4_IS_SLOW from genmake2 (with LET_RS_BE_REAL4):
C
C--   Control use of "double" precision constants.
C     Use D0 where it means REAL*8 but not where it means REAL*16
C
C=== IO related options ===
C--   Flag used to indicate whether Fortran formatted write
C     and read are threadsafe. On SGI the routines can be thread
C     safe, on Sun it is not possible - if you are unsure then
C     undef this option.
C
C--   Flag used to indicate whether Binary write to Local file (i.e.,
C     a different file for each tile) and read are thread-safe.
C
C--   Flag to turn off the writing of error message to ioUnit zero
C
C--   Alternative formulation of BYTESWAP, faster than
C     compiler flag -byteswapio on the Altix.
C
C--   Flag to turn on old default of opening scratch files with the
C     STATUS='SCRATCH' option. This method, while perfectly FORTRAN-standard,
C     caused filename conflicts on some multi-node/multi-processor platforms
C     in the past and has been replace by something (hopefully) more robust.
C
C--   Flag defined for eeboot_minimal.F, eeset_parms.F and open_copy_data_file.F
C     to write STDOUT, STDERR and scratch files from process 0 only.
C WARNING: to use only when absolutely confident that the setup is working
C     since any message (error/warning/print) from any proc <> 0 will be lost.
C
C=== MPI, EXCH and GLOBAL_SUM related options ===
C--   Flag turns off MPI_SEND ready_to_receive polling in the
C     gather_* subroutines to speed up integrations.
C
C--   Control MPI based parallel processing
CXXX We no longer select the use of MPI via this file (CPP_EEOPTIONS.h)
CXXX To use MPI, use an appropriate genmake2 options file or use
CXXX genmake2 -mpi .
CXXX #undef  ALLOW_USE_MPI
C
C--   Control use of communication that might overlap computation.
C     Under MPI selects/deselects "non-blocking" sends and receives.
C--   Control use of communication that is atomic to computation.
C     Under MPI selects/deselects "blocking" sends and receives.
C
C--   Control XY periodicity in processor to grid mappings
C     Note: Model code does not need to know whether a domain is
C           periodic because it has overlap regions for every box.
C           Model assume that these values have been
C           filled in some way.
C
C--   disconnect tiles (no exchange between tiles, just fill-in edges
C     assuming locally periodic subdomain)
C
C--   Always cumulate tile local-sum in the same order by applying MPI allreduce
C     to array of tiles ; can get slower with large number of tiles (big set-up)
C
C--   Alternative way of doing global sum without MPI allreduce call
C     but instead, explicit MPI send & recv calls. Expected to be slower.
C
C--   Alternative way of doing global sum on a single CPU
C     to eliminate tiling-dependent roundoff errors. Note: This is slow.
C
C=== Other options (to add/remove pieces of code) ===
C--   Flag to turn on checking for errors from all threads and procs
C     (calling S/R STOP_IF_ERROR) before stopping.
C
C--   Control use of communication with other component:
C     allow to import and export from/to Coupler interface.
C
C--   Activate some pieces of code for coupling to GEOS AGCM
C
C=== And define Macros ===
CBOP
C     !ROUTINE: CPP_EEMACROS.h
C     !INTERFACE:
C     include "CPP_EEMACROS.h"
C     !DESCRIPTION:
C     *==========================================================*
C     | CPP_EEMACROS.h
C     *==========================================================*
C     | C preprocessor "execution environment" supporting
C     | macros. Use this file to define macros for  simplifying
C     | execution environment in which a model runs - as opposed
C     | to the dynamical problem the model solves.
C     *==========================================================*
CEOP
C
C
C     In general the following convention applies:
C     ALLOW  - indicates an feature will be included but it may
C     CAN      have a run-time flag to allow it to be switched
C              on and off.
C              If ALLOW or CAN directives are "undef'd" this generally
C              means that the feature will not be available i.e. it
C              will not be included in the compiled code and so no
C              run-time option to use the feature will be available.
C
C     ALWAYS - indicates the choice will be fixed at compile time
C              so no run-time option will be present
C
C     Flag used to indicate which flavour of multi-threading
C     compiler directives to use. Only set one of these.
C     USE_SOLARIS_THREADING  - Takes directives for SUN Workshop
C                              compiler.
C     USE_KAP_THREADING      - Takes directives for Kuck and
C                              Associates multi-threading compiler
C                              ( used on Digital platforms ).
C     USE_IRIX_THREADING     - Takes directives for SGI MIPS
C                              Pro Fortran compiler.
C     USE_EXEMPLAR_THREADING - Takes directives for HP SPP series
C                              compiler.
C     USE_C90_THREADING      - Takes directives for CRAY/SGI C90
C                              system F90 compiler.
C
C
C
C
C
C
C--   Define the mapping for the _BARRIER macro
C     On some systems low-level hardware support can be accessed through
C     compiler directives here.
C
C--   Define the mapping for the BEGIN_CRIT() and  END_CRIT() macros.
C     On some systems we simply execute this section only using the
C     master thread i.e. its not really a critical section. We can
C     do this because we do not use critical sections in any critical
C     sections of our code!
C
C--   Define the mapping for the BEGIN_MASTER_SECTION() and
C     END_MASTER_SECTION() macros. These are generally implemented by
C     simply choosing a particular thread to be "the master" and have
C     it alone execute the BEGIN_MASTER..., END_MASTER.. sections.
C
CcnhDebugStarts
C      Alternate form to the above macros that increments (decrements) a counter each
C      time a MASTER section is entered (exited). This counter can then be checked in barrier
C      to try and detect calls to BARRIER within single threaded sections.
C      Using these macros requires two changes to Makefile - these changes are written
C      below.
C      1 - add a filter to the CPP command to kill off commented _MASTER lines
C      2 - add a filter to the CPP output the converts the string N EWLINE to an actual newline.
C      The N EWLINE needs to be changes to have no space when this macro and Makefile changes
C      are used. Its in here with a space to stop it getting parsed by the CPP stage in these
C      comments.
C      #define IF ( a .EQ. 1 ) THEN  IF ( a .EQ. 1 ) THEN  N EWLINE      CALL BARRIER_MS(a)
C      #define ENDIF    CALL BARRIER_MU(a) N EWLINE        ENDIF
C      'CPP = cat $< | $(TOOLSDIR)/set64bitConst.sh |  grep -v '^[cC].*_MASTER' | cpp  -traditional -P'
C      .F.f:
C      $(CPP) $(DEFINES) $(INCLUDES) |  sed 's/N EWLINE/\n/' > $@
CcnhDebugEnds
C
C--   Control storage of floating point operands
C     On many systems it improves performance only to use
C     8-byte precision for time stepped variables.
C     Constant in time terms ( geometric factors etc.. )
C     can use 4-byte precision, reducing memory utilisation and
C     boosting performance because of a smaller working
C     set size. However, on vector CRAY systems this degrades
C     performance.
C- Note: global_sum/max macros were used to switch to  JAM routines (obsolete);
C  in addition, since only the R4 & R8 S/R are coded, GLOBAL RS & RL macros
C  enable to call the corresponding R4 or R8 S/R.
C
C
C
C- Note: a) exch macros were used to switch to  JAM routines (obsolete)
C        b) exch R4 & R8 macros are not practically used ; if needed,
C           will directly call the corrresponding S/R.
C
C--   Control use of JAM routines for Artic network (no longer supported)
C     These invoke optimized versions of "exchange" and "sum" that
C     utilize the programmable aspect of Artic cards.
CXXX No longer supported ; started to remove JAM routines.
CXXX #ifdef LETS_MAKE_JAM
CXXX #define CALL GLOBAL_SUM_R8 ( a, b) CALL GLOBAL_SUM_R8_JAM ( a, b)
CXXX #define CALL GLOBAL_SUM_R8 ( a, b ) CALL GLOBAL_SUM_R8_JAM ( a, b )
CXXX #define CALL EXCH_XY_RS ( a, b ) CALL EXCH_XY_R8_JAM ( a, b )
CXXX #define CALL EXCH_XY_RL ( a, b ) CALL EXCH_XY_R8_JAM ( a, b )
CXXX #define CALL EXCH_XYZ_RS ( a, b ) CALL EXCH_XYZ_R8_JAM ( a, b )
CXXX #define CALL EXCH_XYZ_RL ( a, b ) CALL EXCH_XYZ_R8_JAM ( a, b )
CXXX #endif
C
C--   Control use of "double" precision constants.
C     Use d0 where it means REAL*8 but not where it means REAL*16
C
C--   Substitue for 1.D variables
C     Sun compilers do not use 8-byte precision for literals
C     unless .Dnn is specified. CRAY vector machines use 16-byte
C     precision when they see .Dnn which runs very slowly!
C
C--   Set the format for writing processor IDs, e.g. in S/R eeset_parms
C     and S/R open_copy_data_file. The default of I9.9 should work for
C     a long time (until we will use 10e10 processors and more)
C
C--   Set the format for writing ensemble task IDs in S/R eeset_parms
C     and S/R open_copy_data_file.
C
C--   Set ACTION= in OPEN instruction for input file (before doing IO)
C     leave it empty (if EXCLUDE_OPEN_ACTION) or set it to proper value
C
C
C
C o Include/exclude single header file containing multiple packages options
C   (AUTODIFF, COST, CTRL, ECCO, EXF ...) instead of the standard way where
C   each of the above pkg get its own options from its specific option file.
C   Although this method, inherited from ECCO setup, has been traditionally
C   used for all adjoint built, work is in progress to allow to use the
C   standard method also for adjoint built.
C# include "ECCO_CPPOPTIONS.h"
C
C
C     Package-specific Options & Macros go here
C
C This flag selects the form of COSINE(lat) scaling of bi-harmonic term.
C *only for use on a lat-lon grid*
C Setting this flag here only affects the bi-harmonic tracer terms; to
C use COSINEMETH_III in the momentum equations set it CPP_OPTIONS.h
C
C This selects isotropic scaling of harmonic and bi-harmonic term when
C using the COSINE(lat) scaling.
C Setting this flag here only affects the tracer diffusion terms; to
C use ISOTROPIC_COS_SCALING of the horizontal viscosity terms in the
C momentum equations set it CPP_OPTIONS.h; the following line
C even overrides setting the flag in CPP_OPTIONS.h
C
C As of checkpoint41, the inclusion of multi-dimensional advection
C introduces excessive recomputation/storage for the adjoint.
C We can disable it here using CPP because run-time flags are insufficient.
C
C Use compressible flow method for multi-dim advection instead of old, less
C accurate jmc method. Note: option has no effect on SOM advection which
C always use compressible flow method.
C
C This enable the use of 2nd-Order Moment advection scheme (Prather, 1986) for
C Temperature and Salinity ; due to large memory space (10 times more / tracer)
C requirement, by default, this part of the code is not compiled.
C
C Hack to get rid of negatives caused by Redi.  Works by restricting the
C outgoing flux (only contributions computed in gad_calc_rhs) for each cell
C to be no more than the amount of tracer in the cell (see Smolarkiewicz
C MWR 1989 and Bott MWR 1989).
C The flux contributions computed in gad_calc_rhs which are affected by
C this hack are:
C - explicit diffusion, Redi and the non-local part of KPP
C - advection is affected only if multiDimAdvection=.FALSE.
C - vertical diffusion (including the diagonal contribution from GMRedi)
C   only if implicitDiffusion=.FALSE.
C - GM is affected only if GMREDI_AdvForm=.FALSE.
C
C The parameter SmolarkiewiczMaxFrac (defined in gad_init_fixed.F)
C specifies the maximal fraction of tracer that can leave a cell.
C By default it is 1.  This will prevent the tracer from going negative
C due to contributions from gad_calc_rhs alone.  In the presence of other
C contributions (or roundoff errors), it may be necessary to reduce this
C value to achieve strict positivity.
C
C This hack applies to all tracers except temperature and salinity!
C Do not use with Adams-Bashforth (for ptracers)!
C Do not use with OBCS!
C
C
      SUBROUTINE GAD_OS7MP_ADV_Y_B(bi, bj, k, calccfl, deltatloc, vtrans
     +                             , vtransb, vfld, vfldb, masklocs, q, 
     +                             qb, vt, vtb, mythid)
      IMPLICIT NONE
C
C     == GLobal variables ==
CBOP
C    !ROUTINE: SIZE.h
C    !INTERFACE:
C    include SIZE.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | SIZE.h Declare size of underlying computational grid.
C     *==========================================================*
C     | The design here supports a three-dimensional model grid
C     | with indices I,J and K. The three-dimensional domain
C     | is comprised of nPx*nSx blocks (or tiles) of size sNx
C     | along the first (left-most index) axis, nPy*nSy blocks
C     | of size sNy along the second axis and one block of size
C     | Nr along the vertical (third) axis.
C     | Blocks/tiles have overlap regions of size OLx and OLy
C     | along the dimensions that are subdivided.
C     *==========================================================*
C     \ev
C
C     Voodoo numbers controlling data layout:
C     sNx :: Number of X points in tile.
C     sNy :: Number of Y points in tile.
C     OLx :: Tile overlap extent in X.
C     OLy :: Tile overlap extent in Y.
C     nSx :: Number of tiles per process in X.
C     nSy :: Number of tiles per process in Y.
C     nPx :: Number of processes to use in X.
C     nPy :: Number of processes to use in Y.
C     Nx  :: Number of points in X for the full domain.
C     Ny  :: Number of points in Y for the full domain.
C     Nr  :: Number of points in vertical direction.
CEOP
      INTEGER snx
      INTEGER sny
      INTEGER olx
      INTEGER oly
      INTEGER nsx
      INTEGER nsy
      INTEGER npx
      INTEGER npy
      INTEGER nx
      INTEGER ny
      INTEGER nr
      PARAMETER (snx=62, sny=62, olx=4, oly=4, nsx=1, nsy=1, npx=1, npy=
     +   1, nx=snx*nsx*npx, ny=sny*nsy*npy, nr=31)
C
C     MAX_OLX :: Set to the maximum overlap region size of any array
C     MAX_OLY    that will be exchanged. Controls the sizing of exch
C                routine buffers.
      INTEGER max_olx
      INTEGER max_oly
      PARAMETER (max_olx=olx, max_oly=oly)
C
C
CBOP
C    !ROUTINE: GRID.h
C    !INTERFACE:
C    include GRID.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | GRID.h
C     | o Header file defining model grid.
C     *==========================================================*
C     | Model grid is defined for each process by reference to
C     | the arrays set here.
C     | Notes
C     | =====
C     | The standard MITgcm convention of westmost, southern most
C     | and upper most having the (1,1,1) index is used here.
C     | i.e.
C     |----------------------------------------------------------
C     | (1)  Plan view schematic of model grid (top layer i.e. )
C     |      ================================= ( ocean surface )
C     |                                        ( or top of     )
C     |                                        ( atmosphere    )
C     |      This diagram shows the location of the model
C     |      prognostic variables on the model grid. The "T"
C     |      location is used for all tracers. The figure also
C     |      shows the southern most, western most indexing
C     |      convention that is used for all model variables.
C     |
C     |
C     |             V(i=1,                     V(i=Nx,
C     |               j=Ny+1,                    j=Ny+1,
C     |               k=1)                       k=1)
C     |                /|\                       /|\  "PWX"
C     |       |---------|------------------etc..  |---- *---
C     |       |                     |                   *  |
C     |"PWY"*******************************etc..  **********"PWY"
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x           |             x     *==>U
C     |  j=Ny,|      T(i=1,         |          T(i=Nx,  *(i=Nx+1,
C     |  k=1) |        j=Ny,        |            j=Ny,  *  |j=Ny,
C     |       |        k=1)         |            k=1)   *  |k=1)
C     |
C     |       .                     .                      .
C     |       .                     .                      .
C     |       .                     .                      .
C     |       e                     e                   *  e
C     |       t                     t                   *  t
C     |       c                     c                   *  c
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x           |             x     *  |
C     |  j=2, |      T(i=1,         |          T(i=Nx,  *  |
C     |  k=1) |        j=2,         |            j=2,   *  |
C     |       |        k=1)         |            k=1)   *  |
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |      -----------|------------------etc..  |-----*---
C     |       |       V(i=1,        |           V(i=Nx, *  |
C     |       |         j=2,        |             j=2,  *  |
C     |       |         k=1)        |             k=1)  *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x         ==>U(i=2,       x     *==>U
C     |  j=1, |      T(i=1,         |  j=1,    T(i=Nx,  *(i=Nx+1,
C     |  k=1) |        j=1,         |  k=1)      j=1,   *  |j=1,
C     |       |        k=1)         |            k=1)   *  |k=1)
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |"SB"++>|---------|------------------etc..  |-----*---
C     |      /+\      V(i=1,                    V(i=Nx, *
C     |       +         j=1,                      j=1,  *
C     |       +         k=1)                      k=1)  *
C     |     "WB"                                      "PWX"
C     |
C     |   N, y increasing northwards
C     |  /|\ j increasing northwards
C     |   |
C     |   |
C     |   ======>E, x increasing eastwards
C     |             i increasing eastwards
C     |
C     |    i: East-west index
C     |    j: North-south index
C     |    k: up-down index
C     |    U: x-velocity (m/s)
C     |    V: y-velocity (m/s)
C     |    T: potential temperature (oC)
C     | "SB": Southern boundary
C     | "WB": Western boundary
C     |"PWX": Periodic wrap around in X.
C     |"PWY": Periodic wrap around in Y.
C     |----------------------------------------------------------
C     | (2) South elevation schematic of model grid
C     |     =======================================
C     |     This diagram shows the location of the model
C     |     prognostic variables on the model grid. The "T"
C     |     location is used for all tracers. The figure also
C     |     shows the upper most, western most indexing
C     |     convention that is used for all model variables.
C     |
C     |      "WB"
C     |       +
C     |       +
C     |      \+/       /|\                       /|\       .
C     |"UB"++>|-------- | -----------------etc..  | ----*---
C     |       |    rVel(i=1,        |        rVel(i=Nx, *  |
C     |       |         j=1,        |             j=1,  *  |
C     |       |         k=1)        |             k=1)  *  |
C     |       |                     |                   *  |
C     |U(i=1, ==>       x         ==>U(i=2,       x     *==>U
C     |  j=1, |      T(i=1,         |  j=1,    T(i=Nx,  *(i=Nx+1,
C     |  k=1) |        j=1,         |  k=1)      j=1,   *  |j=1,
C     |       |        k=1)         |            k=1)   *  |k=1)
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |       |-------- | -----------------etc..  | ----*---
C     |       |    rVel(i=1,        |        rVel(i=Nx, *  |
C     |       |         j=1,        |             j=1,  *  |
C     |       |         k=2)        |             k=2)  *  |
C     |
C     |       .                     .                      .
C     |       .                     .                      .
C     |       .                     .                      .
C     |       e                     e                   *  e
C     |       t                     t                   *  t
C     |       c                     c                   *  c
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |                     |                   *  |
C     |       |        /|\          |            /|\    *  |
C     |       |-------- | -----------------etc..  | ----*---
C     |       |    rVel(i=1,        |        rVel(i=Nx, *  |
C     |       |         j=1,        |             j=1,  *  |
C     |       |         k=Nr)       |             k=Nr) *  |
C     |U(i=1, ==>       x         ==>U(i=2,       x     *==>U
C     |  j=1, |      T(i=1,         |  j=1,    T(i=Nx,  *(i=Nx+1,
C     |  k=Nr)|        j=1,         |  k=Nr)     j=1,   *  |j=1,
C     |       |        k=Nr)        |            k=Nr)  *  |k=Nr)
C     |       |                     |                   *  |
C     |"LB"++>==============================================
C     |                                               "PWX"
C     |
C     | Up   increasing upwards.
C     |/|\                                                       .
C     | |
C     | |
C     | =====> E  i increasing eastwards
C     | |         x increasing eastwards
C     | |
C     |\|/
C     | Down,k increasing downwards.
C     |
C     | Note: r => height (m) => r increases upwards
C     |       r => pressure (Pa) => r increases downwards
C     |
C     |
C     |    i: East-west index
C     |    j: North-south index
C     |    k: up-down index
C     |    U: x-velocity (m/s)
C     | rVel: z-velocity ( units of r )
C     |       The vertical velocity variable rVel is in units of
C     |       "r" the vertical coordinate. r in m will give
C     |       rVel m/s. r in Pa will give rVel Pa/s.
C     |    T: potential temperature (oC)
C     | "UB": Upper boundary.
C     | "LB": Lower boundary (always solid - therefore om|w == 0)
C     | "WB": Western boundary
C     |"PWX": Periodic wrap around in X.
C     |----------------------------------------------------------
C     | (3) Views showing nomenclature and indexing
C     |     for grid descriptor variables.
C     |
C     |      Fig 3a. shows the orientation, indexing and
C     |      notation for the grid spacing terms used internally
C     |      for the evaluation of gradient and averaging terms.
C     |      These varaibles are set based on the model input
C     |      parameters which define the model grid in terms of
C     |      spacing in X, Y and Z.
C     |
C     |      Fig 3b. shows the orientation, indexing and
C     |      notation for the variables that are used to define
C     |      the model grid. These varaibles are set directly
C     |      from the model input.
C     |
C     | Figure 3a
C     | =========
C     |       |------------------------------------
C     |       |                       |
C     |"PWY"********************************* etc...
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |
C     |       .                       .
C     |       .                       .
C     |       .                       .
C     |       e                       e
C     |       t                       t
C     |       c                       c
C     |       |-----------v-----------|-----------v----------|-
C     |       |                       |                      |
C     |       |                       |                      |
C     |       |                       |                      |
C     |       |                       |                      |
C     |       |                       |                      |
C     |       u<--dxF(i=1,j=2,k=1)--->u           t          |
C     |       |/|\       /|\          |                      |
C     |       | |         |           |                      |
C     |       | |         |           |                      |
C     |       | |         |           |                      |
C     |       |dyU(i=1,  dyC(i=1,     |                      |
C     | ---  ---|--j=2,---|--j=2,-----------------v----------|-
C     | /|\   | |  k=1)   |  k=1)     |          /|\         |
C     |  |    | |         |           |          dyF(i=2,    |
C     |  |    | |         |           |           |  j=1,    |
C     |dyG(   |\|/       \|/          |           |  k=1)    |
C     |   i=1,u---        t<---dxC(i=2,j=1,k=1)-->t          |
C     |   j=1,|                       |           |          |
C     |   k=1)|                       |           |          |
C     |  |    |                       |           |          |
C     |  |    |                       |           |          |
C     | \|/   |           |<---dxV(i=2,j=1,k=1)--\|/         |
C     |"SB"++>|___________v___________|___________v__________|_
C     |       <--dxG(i=1,j=1,k=1)----->
C     |      /+\                                              .
C     |       +
C     |       +
C     |     "WB"
C     |
C     |   N, y increasing northwards
C     |  /|\ j increasing northwards
C     |   |
C     |   |
C     |   ======>E, x increasing eastwards
C     |             i increasing eastwards
C     |
C     |    i: East-west index
C     |    j: North-south index
C     |    k: up-down index
C     |    u: x-velocity point
C     |    V: y-velocity point
C     |    t: tracer point
C     | "SB": Southern boundary
C     | "WB": Western boundary
C     |"PWX": Periodic wrap around in X.
C     |"PWY": Periodic wrap around in Y.
C     |
C     | Figure 3b
C     | =========
C     |
C     |       .                       .
C     |       .                       .
C     |       .                       .
C     |       e                       e
C     |       t                       t
C     |       c                       c
C     |       |-----------v-----------|-----------v--etc...
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       u<--delX(i=1)---------->u           t
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |                       |
C     |       |-----------v-----------------------v--etc...
C     |       |          /|\          |
C     |       |           |           |
C     |       |           |           |
C     |       |           |           |
C     |       u        delY(j=1)      |           t
C     |       |           |           |
C     |       |           |           |
C     |       |           |           |
C     |       |           |           |
C     |       |          \|/          |
C     |"SB"++>|___________v___________|___________v__etc...
C     |      /+\                                                 .
C     |       +
C     |       +
C     |     "WB"
C     |
C     *==========================================================*
C     \ev
CEOP
C
C     Macros that override/modify standard definitions
C
CBOP
C    !ROUTINE: GRID_MACROS.h
C    !INTERFACE:
C    include GRID_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | GRID_MACROS.h
C     *==========================================================*
C     | These macros are used to substitute definitions for
C     | GRID.h variables for particular configurations.
C     | In setting these variables the following convention
C     | applies.
C     | undef  phi_CONST   - Indicates the variable phi is fixed
C     |                      in X, Y and Z.
C     | undef  phi_FX      - Indicates the variable phi only
C     |                      varies in X (i.e.not in X or Z).
C     | undef  phi_FY      - Indicates the variable phi only
C     |                      varies in Y (i.e.not in X or Z).
C     | undef  phi_FXY     - Indicates the variable phi only
C     |                      varies in X and Y ( i.e. not Z).
C     *==========================================================*
C     \ev
CEOP
C
C
CBOP
C    !ROUTINE: DXC_MACROS.h
C    !INTERFACE:
C    include DXC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXC_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DXF_MACROS.h
C    !INTERFACE:
C    include DXF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXF_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DXG_MACROS.h
C    !INTERFACE:
C    include DXG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXG_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DXV_MACROS.h
C    !INTERFACE:
C    include DXV_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DXV_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYC_MACROS.h
C    !INTERFACE:
C    include DYC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYC_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYF_MACROS.h
C    !INTERFACE:
C    include DYF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYF_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYG_MACROS.h
C    !INTERFACE:
C    include DYG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYG_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: DYU_MACROS.h
C    !INTERFACE:
C    include DYU_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | DYU_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: HFACC_MACROS.h
C    !INTERFACE:
C    include HFACC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | HFACC_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: HFACS_MACROS.h
C    !INTERFACE:
C    include HFACS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | HFACS_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: HFACW_MACROS.h
C    !INTERFACE:
C    include HFACW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | HFACW_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXC_MACROS.h
C    !INTERFACE:
C    include RECIP_DXC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXC_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXF_MACROS.h
C    !INTERFACE:
C    include RECIP_DXF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXF_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXG_MACROS.h
C    !INTERFACE:
C    include RECIP_DXG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXG_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DXV_MACROS.h
C    !INTERFACE:
C    include RECIP_DXV_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DXV_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYC_MACROS.h
C    !INTERFACE:
C    include RECIP_DYC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYC_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYF_MACROS.h
C    !INTERFACE:
C    include RECIP_DYF_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYF_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYG_MACROS.h
C    !INTERFACE:
C    include RECIP_DYG_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYG_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_DYU_MACROS.h
C    !INTERFACE:
C    include RECIP_DYU_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_DYU_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_HFACC_MACROS.h
C    !INTERFACE:
C    include RECIP_HFACC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_HFACC_MACROS.h                                      
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_HFACS_MACROS.h
C    !INTERFACE:
C    include RECIP_HFACS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_HFACS_MACROS.h                                      
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: RECIP_HFACW_MACROS.h
C    !INTERFACE:
C    include RECIP_HFACW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RECIP_HFACW_MACROS.h                                      
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: XC_MACROS.h
C    !INTERFACE:
C    include XC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | XC_MACROS.h                                               
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: YC_MACROS.h
C    !INTERFACE:
C    include YC_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | YC_MACROS.h                                               
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: RA_MACROS.h
C    !INTERFACE:
C    include RA_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RA_MACROS.h                                               
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
CBOP
C    !ROUTINE: RAW_MACROS.h
C    !INTERFACE:
C    include RAW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RAW_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
CBOP
C    !ROUTINE: RAS_MACROS.h
C    !INTERFACE:
C    include RAS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | RAS_MACROS.h                                              
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: MASKW_MACROS.h
C    !INTERFACE:
C    include MASKW_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | MASKW_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: MASKS_MACROS.h
C    !INTERFACE:
C    include MASKS_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | MASKS_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
C
CBOP
C    !ROUTINE: TANPHIATU_MACROS.h
C    !INTERFACE:
C    include TANPHIATU_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | TANPHIATU_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: TANPHIATV_MACROS.h
C    !INTERFACE:
C    include TANPHIATV_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | TANPHIATV_MACROS.h                                        
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C
CBOP
C    !ROUTINE: FCORI_MACROS.h
C    !INTERFACE:
C    include FCORI_MACROS.h
C    !DESCRIPTION: \bv
C     *==========================================================*
C     | FCORI_MACROS.h                                            
C     *==========================================================*
C     | These macros are used to reduce memory requirement and/or 
C     | memory references when variables are fixed along a given  
C     | axis or axes.                                             
C     *==========================================================*
C     \ev
CEOP
C
C
C
C
C
C--   COMMON /GRID_RL/ RL valued grid defining variables.
C     deepFacC  :: deep-model grid factor (fct of vertical only) for dx,dy
C     deepFacF     at level-center (deepFacC)  and level interface (deepFacF)
C     deepFac2C :: deep-model grid factor (fct of vertical only) for area dx*dy
C     deepFac2F    at level-center (deepFac2C) and level interface (deepFac2F)
C     gravitySign :: indicates the direction of gravity relative to R direction
C                   (= -1 for R=Z (Z increases upward, -gravity direction  )
C                   (= +1 for R=P (P increases downward, +gravity direction)
C     rkSign     :: Vertical coordinate to vertical index orientation.
C                   ( +1 same orientation, -1 opposite orientation )
C     globalArea :: Domain Integrated horizontal Area [m2]
      COMMON /grid_rl/ cosfacu, cosfacv, sqcosfacu, sqcosfacv, deepfacc
     +, deepfac2c, recip_deepfacc, recip_deepfac2c, deepfacf, deepfac2f
     +, recip_deepfacf, recip_deepfac2f, gravitysign, rksign, globalarea
      REAL*8 cosfacu(1-oly:sny+oly, nsx, nsy)
      REAL*8 cosfacv(1-oly:sny+oly, nsx, nsy)
      REAL*8 sqcosfacu(1-oly:sny+oly, nsx, nsy)
      REAL*8 sqcosfacv(1-oly:sny+oly, nsx, nsy)
      REAL*8 deepfacc(nr)
      REAL*8 deepfac2c(nr)
      REAL*8 deepfacf(nr+1)
      REAL*8 deepfac2f(nr+1)
      REAL*8 recip_deepfacc(nr)
      REAL*8 recip_deepfac2c(nr)
      REAL*8 recip_deepfacf(nr+1)
      REAL*8 recip_deepfac2f(nr+1)
      REAL*8 gravitysign
      REAL*8 rksign
      REAL*8 globalarea
C
C--   COMMON /GRID_RS/ RS valued grid defining variables.
C     dxC     :: Cell center separation in X across western cell wall (m)
C     dxG     :: Cell face separation in X along southern cell wall (m)
C     dxF     :: Cell face separation in X thru cell center (m)
C     dxV     :: V-point separation in X across south-west corner of cell (m)
C     dyC     :: Cell center separation in Y across southern cell wall (m)
C     dyG     :: Cell face separation in Y along western cell wall (m)
C     dyF     :: Cell face separation in Y thru cell center (m)
C     dyU     :: U-point separation in Y across south-west corner of cell (m)
C     drC     :: Cell center separation along Z axis ( units of r ).
C     drF     :: Cell face separation along Z axis ( units of r ).
C     R_low   :: base of fluid in r_unit (Depth(m) / Pressure(Pa) at top Atmos.)
C     rLowW   :: base of fluid column in r_unit at Western  edge location.
C     rLowS   :: base of fluid column in r_unit at Southern edge location.
C     Ro_surf :: surface reference (at rest) position, r_unit.
C     rSurfW  :: surface reference position at Western  edge location [r_unit].
C     rSurfS  :: surface reference position at Southern edge location [r_unit].
C     hFac    :: Fraction of cell in vertical which is open i.e how
C              "lopped" a cell is (dimensionless scale factor).
C              Note: The code needs terms like MIN(hFac,hFac(I-1))
C                    On some platforms it may be better to precompute
C                    hFacW, hFacS, ... here than do MIN on the fly.
C     maskInC :: Cell Center 2-D Interior mask (i.e., zero beyond OB)
C     maskInW :: West  face 2-D Interior mask (i.e., zero on and beyond OB)
C     maskInS :: South face 2-D Interior mask (i.e., zero on and beyond OB)
C     maskC   :: cell Center land mask
C     maskW   :: West face land mask
C     maskS   :: South face land mask
C     recip_dxC   :: Reciprocal of dxC
C     recip_dxG   :: Reciprocal of dxG
C     recip_dxF   :: Reciprocal of dxF
C     recip_dxV   :: Reciprocal of dxV
C     recip_dyC   :: Reciprocal of dxC
C     recip_dyG   :: Reciprocal of dyG
C     recip_dyF   :: Reciprocal of dyF
C     recip_dyU   :: Reciprocal of dyU
C     recip_drC   :: Reciprocal of drC
C     recip_drF   :: Reciprocal of drF
C     recip_Rcol  :: Inverse of cell center column thickness (1/r_unit)
C     recip_hFacC :: Inverse of cell open-depth f[X,Y,Z] ( dimensionless ).
C     recip_hFacW    rhFacC center, rhFacW west, rhFacS south.
C     recip_hFacS   Note: This is precomputed here because it involves division.
C     xC     :: X-coordinate of cell center f[X,Y]. The units of xc, yc
C               depend on the grid. They are not used in differencing or
C               averaging but are just a convient quantity for I/O,
C               diagnostics etc.. As such xc is in m for cartesian
C               coordinates but degrees for spherical polar.
C     yC     :: Y-coordinate of center of cell f[X,Y].
C     yG     :: Y-coordinate of corner of cell (c-grid vorticity point) f[X,Y].
C     rA     :: R-face are f[X,Y] ( m^2 ).
C               Note: In a cartesian framework rA is simply dx*dy,
C                   however we use rA to allow for non-globally
C                   orthogonal coordinate frames (with appropriate
C                   metric terms).
C     rC     :: R-coordinate of center of cell f[Z] (units of r).
C     rF     :: R-coordinate of face of cell f[Z] (units of r).
C - *HybSigm* - :: Hybrid-Sigma vert. Coord coefficients
C     aHybSigmF    at level-interface (*HybSigmF) and level-center (*HybSigmC)
C     aHybSigmC    aHybSigm* = constant r part, bHybSigm* = sigma part, such as
C     bHybSigmF    r(ij,k,t) = rLow(ij) + aHybSigm(k)*[rF(1)-rF(Nr+1)]
C     bHybSigmC              + bHybSigm(k)*[eta(ij,t)+Ro_surf(ij) - rLow(ij)]
C     dAHybSigF :: vertical increment of Hybrid-Sigma coeff.: constant r part,
C     dAHybSigC    between interface (dAHybSigF) and between center (dAHybSigC)
C     dBHybSigF :: vertical increment of Hybrid-Sigma coefficient: sigma part,
C     dBHybSigC    between interface (dBHybSigF) and between center (dBHybSigC)
C     tanPhiAtU :: tan of the latitude at U point. Used for spherical polar
C                  metric term in U equation.
C     tanPhiAtV :: tan of the latitude at V point. Used for spherical polar
C                  metric term in V equation.
C     angleCosC :: cosine of grid orientation angle relative to Geographic
C direction at cell center: alpha=(Eastward_dir,grid_uVel_dir)=(North_d,vVel_d)
C     angleSinC :: sine   of grid orientation angle relative to Geographic
C direction at cell center: alpha=(Eastward_dir,grid_uVel_dir)=(North_d,vVel_d)
C     u2zonDir  :: cosine of grid orientation angle at U point location
C     v2zonDir  :: minus sine of  orientation angle at V point location
C     fCori     :: Coriolis parameter at grid Center point
C     fCoriG    :: Coriolis parameter at grid Corner point
C     fCoriCos  :: Coriolis Cos(phi) parameter at grid Center point (for NH)
C
      COMMON /grid_rs/ dxc, dxf, dxg, dxv, dyc, dyf, dyg, dyu, rloww, 
     +rlows, ro_surf, rsurfw, rsurfs, recip_dxc, recip_dxf, recip_dxg, 
     +recip_dxv, recip_dyc, recip_dyf, recip_dyg, recip_dyu, xc, yc, ra
     +, raw, ras, raz, xg, yg, maskinc, maskinw, maskins, maskc, maskw, 
     +masks, recip_ra, recip_raw, recip_ras, recip_raz, drc, drf, 
     +recip_drc, recip_drf, rc, rf, ahybsigmf, bhybsigmf, ahybsigmc, 
     +bhybsigmc, dahybsigf, dbhybsigf, dbhybsigc, dahybsigc, tanphiatu, 
     +tanphiatv, anglecosc, anglesinc, u2zondir, v2zondir, fcori, fcorig
     +, fcoricos
      REAL*8 dxc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dxf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dxg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dxv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 dyu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rloww(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rlows(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ro_surf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rsurfw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 rsurfs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dxv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyf(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_dyu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 xc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 xg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 yc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 yg(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ra(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 raw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 ras(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 raz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_ra(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_raw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_ras(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_raz(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskinc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskinw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskins(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 maskc(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 maskw(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 masks(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 drc(nr+1)
      REAL*8 drf(nr)
      REAL*8 recip_drc(nr+1)
      REAL*8 recip_drf(nr)
      REAL*8 rc(nr)
      REAL*8 rf(nr+1)
      REAL*8 ahybsigmf(nr+1)
      REAL*8 bhybsigmf(nr+1)
      REAL*8 ahybsigmc(nr)
      REAL*8 bhybsigmc(nr)
      REAL*8 dahybsigf(nr)
      REAL*8 dbhybsigf(nr)
      REAL*8 dbhybsigc(nr+1)
      REAL*8 dahybsigc(nr+1)
      REAL*8 tanphiatu(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 tanphiatv(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 anglecosc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 anglesinc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 u2zondir(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 v2zondir(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fcori(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fcorig(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 fcoricos(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C--   COMMON /GRID_VAR_RS/ potentially time-dependent or active RS
C     valued grid defining variables. These grid defining variables are
C     time-dependent when using a non-linear free surface, or they are
C     active in an AD sense when using depth as a control parameter, or
C     both.
      COMMON /grid_var_rs/ hfacc, hfacw, hfacs, recip_hfacc, recip_hfacw
     +, recip_hfacs, r_low, recip_rcol
      REAL*8 hfacc(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hfacw(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 hfacs(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacc(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacw(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 recip_hfacs(1-olx:snx+olx, 1-oly:sny+oly, nr, nsx, nsy)
      REAL*8 r_low(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      REAL*8 recip_rcol(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C
C--   COMMON /GRID_I/ INTEGER valued grid defining variables.
C     kSurfC  :: vertical index of the surface tracer cell
C     kSurfW  :: vertical index of the surface U point
C     kSurfS  :: vertical index of the surface V point
C     kLowC   :: index of the r-lowest "wet cell" (2D)
C IMPORTANT: kLowC = 0 and kSurfC,W,S = Nr+1 (or =Nr+2 on a thin-wall)
C            where the fluid column is empty (continent)
      COMMON /grid_i/ ksurfc, ksurfw, ksurfs, klowc
      INTEGER ksurfc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      INTEGER ksurfw(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      INTEGER ksurfs(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
      INTEGER klowc(1-olx:snx+olx, 1-oly:sny+oly, nsx, nsy)
C
C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
CBOP
C !ROUTINE: GAD.h
C
C !INTERFACE:
C #include "GAD.h"
C
C !DESCRIPTION:
C Contains enumerated constants for distinguishing between different
C advection schemes and tracers.
C
C Unfortunately, there is no easy way to make use of the
C tokens in namelist input so for now we have to enter the
C tokens value into "data" (ie. 2 for 2nd order etc.)
C
C !USES:
C
C !DEFINED PARAMETERS:
C
C ENUM_UPWIND_1RST :: 1rst Order Upwind
      INTEGER enum_upwind_1rst
      PARAMETER (enum_upwind_1rst=1)
C
C ENUM_CENTERED_2ND :: Centered 2nd order
      INTEGER enum_centered_2nd
      PARAMETER (enum_centered_2nd=2)
C
C ENUM_UPWIND_3RD :: 3rd order upwind
      INTEGER enum_upwind_3rd
      PARAMETER (enum_upwind_3rd=3)
C
C ENUM_CENTERED_4TH :: Centered 4th order
      INTEGER enum_centered_4th
      PARAMETER (enum_centered_4th=4)
C
C ENUM_DST2 :: 2nd Order Direct Space and Time (= Lax-Wendroff)
      INTEGER enum_dst2
      PARAMETER (enum_dst2=20)
C
C ENUM_FLUX_LIMIT :: Non-linear flux limiter
      INTEGER enum_flux_limit
      PARAMETER (enum_flux_limit=77)
C
C ENUM_DST3 :: 3rd Order Direst Space and Time
      INTEGER enum_dst3
      PARAMETER (enum_dst3=30)
C
C ENUM_DST3_FLUX_LIMIT :: 3-DST flux limited
      INTEGER enum_dst3_flux_limit
      PARAMETER (enum_dst3_flux_limit=33)
C
C ENUM_OS7MP :: 7th Order One Step method with Monotonicity Preserving Limiter
      INTEGER enum_os7mp
      PARAMETER (enum_os7mp=7)
C
C ENUM_SOM_PRATHER :: 2nd Order-Moment Advection Scheme, Prather, 1986
      INTEGER enum_som_prather
      PARAMETER (enum_som_prather=80)
C
C ENUM_SOM_LIMITER :: 2nd Order-Moment Advection Scheme, Prather Limiter
      INTEGER enum_som_limiter
      PARAMETER (enum_som_limiter=81)
C
C ENUM_PPM_NULL :: piecewise parabolic method with "null" limiter
      INTEGER enum_ppm_null_limit
      PARAMETER (enum_ppm_null_limit=40)
C
C ENUM_PPM_MONO :: piecewise parabolic method with "mono" limiter
      INTEGER enum_ppm_mono_limit
      PARAMETER (enum_ppm_mono_limit=41)
C
C ENUM_PPM_WENO :: piecewise parabolic method with "weno" limiter
      INTEGER enum_ppm_weno_limit
      PARAMETER (enum_ppm_weno_limit=42)
C
C ENUM_PQM_NULL :: piecewise quartic method with "null" limiter
      INTEGER enum_pqm_null_limit
      PARAMETER (enum_pqm_null_limit=50)
C
C ENUM_PQM_MONO :: piecewise quartic method with "mono" limiter
      INTEGER enum_pqm_mono_limit
      PARAMETER (enum_pqm_mono_limit=51)
C
C ENUM_PQM_WENO :: piecewise quartic method with "weno" limiter
      INTEGER enum_pqm_weno_limit
      PARAMETER (enum_pqm_weno_limit=52)
C
C GAD_Scheme_MaxNum :: maximum possible number for an advection scheme
      INTEGER gad_scheme_maxnum
      PARAMETER (gad_scheme_maxnum=100)
C
C nSOM :: number of 1rst & 2nd Order-Moments: 1+1 (1D), 2+3 (2D), 3+6 (3D)
      INTEGER nsom
      PARAMETER (nsom=3+6)
C
C oneSixth :: Third/fourth order interpolation factor
      REAL*8 onesixth
      PARAMETER (onesixth=1.d0/6.d0)
C
C loop range for computing vertical advection tendency
C  iMinAdvR,iMaxAdvR  :: 1rst index (X-dir) loop range for vertical advection
C  jMinAdvR,jMaxAdvR  :: 2nd  index (Y-dir) loop range for vertical advection
      INTEGER iminadvr, imaxadvr, jminadvr, jmaxadvr
      PARAMETER (iminadvr=1, imaxadvr=snx)
      PARAMETER (jminadvr=1, jmaxadvr=sny)
C
C Differentiate between tracers (needed for KPP - arrgh!!!)
Cph                              and GMRedi arrgh*arrgh!!!)
Cph  indices are used for TAF key computations, so need to
Cph  running from 1, 2, ...
C
C GAD_TEMPERATURE :: temperature
      INTEGER gad_temperature
      PARAMETER (gad_temperature=1)
C GAD_SALINITY :: salinity
      INTEGER gad_salinity
      PARAMETER (gad_salinity=2)
C GAD_TR1 :: passive tracer 1
      INTEGER gad_tr1
      PARAMETER (gad_tr1=3)
CEOP
C
C--   COMMON /GAD_PARM_C/ Character parameters for GAD pkg routines
C      somSfx       :: 1rst & 2nd Order moment suffix
      CHARACTER*2 somsfx(nsom)
      COMMON /gad_parm_c/ somsfx
C
C--   COMMON /GAD_PARM_I/ Integer parameters for GAD pkg routines
C GAD_OlMinSize     :: overlap minimum size for GAD routines
C           1: min required; 2: to add to current min; 3: factor to apply
      INTEGER gad_olminsize(3)
      COMMON /gad_parm_i/ gad_olminsize
C
C--   COMMON /GAD_PARM_L/ Logical parameters for GAD pkg routines
C tempSOM_Advection :: set to T if using 2nd-Order Moment advection for Temp
C saltSOM_Advection :: set to T if using 2nd-Order Moment advection for Salt
C tempMultiDimAdvec :: set to T if using multi-dim advection for Temp
C saltMultiDimAdvec :: set to T if using multi-dim advection for Salt
C AdamsBashforthGt  :: apply Adams-Bashforth extrapolation on T tendency (=Gt)
C AdamsBashforthGs  :: apply Adams-Bashforth extrapolation on S tendency (=Gs)
C AdamsBashforth_T  :: apply Adams-Bashforth extrapolation on Pot.Temp.
C AdamsBashforth_S  :: apply Adams-Bashforth extrapolation on Salinity
      LOGICAL tempsom_advection
      LOGICAL saltsom_advection
      LOGICAL tempmultidimadvec
      LOGICAL saltmultidimadvec
      LOGICAL adamsbashforthgt
      LOGICAL adamsbashforthgs
      LOGICAL adamsbashforth_t
      LOGICAL adamsbashforth_s
      COMMON /gad_parm_l/ tempsom_advection, saltsom_advection, 
     +tempmultidimadvec, saltmultidimadvec, adamsbashforthgt, 
     +adamsbashforthgs, adamsbashforth_t, adamsbashforth_s
C
      REAL*8 smolarkiewiczmaxfrac
      COMMON /gad_smol/ smolarkiewiczmaxfrac
C
CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
C
C     == Routine arguments ==
      INTEGER bi, bj, k
      LOGICAL calccfl
      REAL*8 deltatloc
      REAL*8 vtrans(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 vtransb(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 vfld(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 vfldb(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 masklocs(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 q(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 qb(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 vt(1-olx:snx+olx, 1-oly:sny+oly)
      REAL*8 vtb(1-olx:snx+olx, 1-oly:sny+oly)
      INTEGER mythid
C
C     == Local variables ==
      INTEGER i, j
      REAL*8 cfl, psi
      REAL*8 cflb, psib
      REAL*8 vloc, fac, delip, deli, phi, eps, rp1h, rp1h_cfl
      REAL*8 vlocb, facb, delipb, delib, phib, rp1hb, rp1h_cflb
      REAL*8 recip_delip, recip_deli
      REAL*8 recip_delipb, recip_delib
      REAL*8 qippp, qipp, qip, qi, qim, qimm, qimmm
      REAL*8 qippb, qipb, qib, qimb, qimmb, qimmmb
      REAL*8 mskipp, mskip, mski, mskim, mskimm, mskimmm
      REAL*8 d2, d2p1, d2m1, a, b, c, d
      REAL*8 d2b, d2p1b, d2m1b, ab, bb, cb, db
      REAL*8 dp1h, dm1h, phimd, philc, phimin, phimax
      REAL*8 dp1hb, dm1hb, phimdb, philcb, phiminb, phimaxb
      REAL*8 delm, delp, delmm, delpp, delmmm, delppp
      REAL*8 delmb, delpb, delmmb, delppb, delmmmb
      REAL*8 del2mm, del2m, del2, del2p, del2pp
      REAL*8 del2mmb, del2mb, del2b, del2pb, del2ppb
      REAL*8 del3mm, del3m, del3p, del3pp
      REAL*8 del3mmb, del3mb, del3pb, del3ppb
      REAL*8 del4m, del4, del4p
      REAL*8 del4mb, del4b, del4pb
      REAL*8 del5m, del5p
      REAL*8 del5mb, del5pb
      REAL*8 del6
      REAL*8 del6b
      INTRINSIC ABS
      INTRINSIC SIGN
      INTRINSIC MAX
      INTRINSIC MIN
      REAL*8 x1
      REAL*8 x1b
      REAL*8 x2
      REAL*8 x2b
      REAL*8 x3
      REAL*8 x3b
      REAL*8 x4
      REAL*8 x4b
      REAL*8 x5
      REAL*8 x5b
      DOUBLE PRECISION x6
      DOUBLE PRECISION x6b
      DOUBLE PRECISION y1
      DOUBLE PRECISION y1b
      REAL*8 x7
      REAL*8 x7b
      REAL*8 y2
      REAL*8 y2b
      REAL*8 y3
      REAL*8 y3b
      REAL*8 x8
      REAL*8 x8b
      REAL*8 y4
      REAL*8 y4b
      REAL*8 x9
      REAL*8 x9b
      REAL*8 x10
      REAL*8 x10b
      REAL*8 y5
      REAL*8 y5b
      REAL*8 x11
      REAL*8 x11b
      DOUBLE PRECISION x12
      DOUBLE PRECISION x12b
      DOUBLE PRECISION x13
      DOUBLE PRECISION x13b
      REAL*8 x14
      REAL*8 x14b
      REAL*8 y6
      REAL*8 y6b
      REAL*8 x15
      REAL*8 x15b
      REAL*8 y7
      REAL*8 y7b
      REAL*8 max1
      REAL*8 max1b
      REAL*8 max2
      REAL*8 max2b
      REAL*8 max3
      REAL*8 max3b
      REAL*8 max4
      REAL*8 max4b
      REAL*8 min1
      REAL*8 min1b
      REAL*8 min2
      REAL*8 min2b
      REAL*8 temp
      REAL*8 tempb
      INTEGER*4 branch
C
      eps = 1.d-20
      DO j=1-oly+4,sny+oly-3
        DO i=1-olx,snx+olx
C
          vloc = vfld(i, j)
          CALL PUSHREAL8(cfl)
          cfl = vloc
          IF (calccfl) THEN
            x1 = vloc*deltatloc*recip_dyc(i, j, bi, bj)
            IF (x1 .GE. 0.) THEN
              cfl = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              cfl = -x1
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
C
          IF (vtrans(i, j) .GT. 0.d0) THEN
            qipp = q(i, j+1)
            qip = q(i, j)
            CALL PUSHREAL8(qi)
            qi = q(i, j-1)
            qim = q(i, j-2)
            qimm = q(i, j-3)
            qimmm = q(i, j-4)
C
            CALL PUSHREAL8(mskip)
            mskip = masklocs(i, j+1)
            CALL PUSHREAL8(mski)
            mski = masklocs(i, j)
            CALL PUSHREAL8(mskim)
            mskim = masklocs(i, j-1)
            CALL PUSHREAL8(mskimm)
            mskimm = masklocs(i, j-2)
            CALL PUSHREAL8(mskimmm)
            mskimmm = masklocs(i, j-3)
            CALL PUSHCONTROL2B(0)
          ELSE IF (vtrans(i, j) .LT. 0.d0) THEN
            qipp = q(i, j-2)
            qip = q(i, j-1)
            CALL PUSHREAL8(qi)
            qi = q(i, j)
            qim = q(i, j+1)
            qimm = q(i, j+2)
            qimmm = q(i, j+3)
C
            CALL PUSHREAL8(mskip)
            mskip = masklocs(i, j-1)
            CALL PUSHREAL8(mski)
            mski = masklocs(i, j)
            CALL PUSHREAL8(mskim)
            mskim = masklocs(i, j+1)
            CALL PUSHREAL8(mskimm)
            mskimm = masklocs(i, j+2)
            CALL PUSHREAL8(mskimmm)
            mskimmm = masklocs(i, j+3)
            CALL PUSHCONTROL2B(1)
          ELSE
            qipp = 0.d0
            qip = 0.d0
            CALL PUSHREAL8(qi)
            qi = 0.d0
            qim = 0.d0
            qimm = 0.d0
            qimmm = 0.d0
C
            CALL PUSHREAL8(mskip)
            mskip = 0.d0
            CALL PUSHREAL8(mski)
            mski = 0.d0
            CALL PUSHREAL8(mskim)
            mskim = 0.d0
            CALL PUSHREAL8(mskimm)
            mskimm = 0.d0
            CALL PUSHREAL8(mskimmm)
            mskimmm = 0.d0
            CALL PUSHCONTROL2B(2)
          END IF
C
          IF (vtrans(i, j) .NE. 0.d0) THEN
C        2nd order correction [i i-1]
            CALL PUSHREAL8(fac)
            fac = 1.d0
            delp = (qip-qi)*mski
            CALL PUSHREAL8(phi)
            phi = fac*delp
C        3rd order correction [i i-1 i-2]
            CALL PUSHREAL8(fac)
            fac = fac*(cfl+1.d0)/3.d0
            delm = (qi-qim)*mskim
            CALL PUSHREAL8(del2)
            del2 = delp - delm
            phi = phi - fac*del2
C        4th order correction [i+1 i i-1 i-2]
            CALL PUSHREAL8(fac)
            fac = fac*(cfl-2.d0)/4.d0
            delpp = (qipp-qip)*mskip*mski
            del2p = delpp - delp
            CALL PUSHREAL8(del3p)
            del3p = del2p - del2
            phi = phi + fac*del3p
C        5th order correction [i+1 i i-1 i-2 i-3]
            CALL PUSHREAL8(fac)
            fac = fac*(cfl-3.d0)/5.d0
            delmm = (qim-qimm)*mskimm*mskim
            del2m = delm - delmm
            del3m = del2 - del2m
            CALL PUSHREAL8(del4)
            del4 = del3p - del3m
            phi = phi + fac*del4
C        6th order correction [i+2 i+1 i i-1 i-2 i-3]
            CALL PUSHREAL8(fac)
            fac = fac*(cfl+2.d0)/6.d0
            del2pp = delpp - delp
            del3pp = del2pp - del2p
            del4p = del3pp - del3p
            CALL PUSHREAL8(del5p)
            del5p = del4p - del4
            phi = phi + fac*del5p
C        7th order correction [i+2 i+1 i i-1 i-2 i-3 i-4]
            CALL PUSHREAL8(fac)
            fac = fac*(cfl+2.d0)/7.d0
            delmmm = (qimm-qimmm)*mskimmm*mskimm*mskim
            del2mm = delmm - delmmm
            del3mm = del2m - del2mm
            del4m = del3m - del3mm
            del5m = del4 - del4m
            CALL PUSHREAL8(del6)
            del6 = del5p - del5m
            phi = phi - fac*del6
C
            CALL PUSHREAL8(delip)
            delip = (qip-qi)*mski
            IF (delip .GE. 0.) THEN
              x2 = delip
              CALL PUSHCONTROL1B(0)
            ELSE
              x2 = -delip
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x2 .LT. eps) THEN
              CALL PUSHREAL8(max1)
              max1 = eps
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(max1)
              max1 = x2
              CALL PUSHCONTROL1B(1)
            END IF
C        Phi = sign(1.D0,Phi)*sign(1.D0,DelIp)
C    &        *abs(Phi+Eps)/abs(DelIp+Eps)
C--   simplify and avoid division by zero
            CALL PUSHREAL8(recip_delip)
            recip_delip = SIGN(1.d0, delip)/max1
            CALL PUSHREAL8(phi)
            phi = phi*recip_delip
C
            CALL PUSHREAL8(deli)
            deli = (qi-qim)*mskim
            IF (deli .GE. 0.) THEN
              x3 = deli
              CALL PUSHCONTROL1B(0)
            ELSE
              x3 = -deli
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x3 .LT. eps) THEN
              CALL PUSHREAL8(max2)
              max2 = eps
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(max2)
              max2 = x3
              CALL PUSHCONTROL1B(1)
            END IF
C        rp1h =sign(1.D0,DelI)*sign(1.D0,DelIp)
C    &        *abs(DelI+Eps)/abs(DelIp+Eps)
C--   simplify and avoid division by zero
            CALL PUSHREAL8(recip_deli)
            recip_deli = SIGN(1.d0, deli)/max2
            CALL PUSHREAL8(rp1h)
            rp1h = deli*recip_delip
            CALL PUSHREAL8(rp1h_cfl)
            rp1h_cfl = rp1h/(cfl+eps)
C
C        TVD limiter
C        Phi = max(0.D0, min( 2./(1-cfl), Phi, 2.*rp1h_cfl ) )
C
C        MP limiter
C( ( Qip + Qim ) - 2.*Qi  ) * MskI * MskIm
            d2 = del2
C( ( Qipp + Qi ) - 2.*Qip ) * MskIp * MskI
            d2p1 = del2p
C( ( Qi + Qimm ) - 2.*Qim ) * MskIm * MskImm
            d2m1 = del2m
            a = 4.d0*d2 - d2p1
            b = 4.d0*d2p1 - d2
            c = d2
            d = d2p1
            IF (a .GT. b) THEN
              x8 = b
              CALL PUSHCONTROL1B(0)
            ELSE
              x8 = a
              CALL PUSHCONTROL1B(1)
            END IF
            IF (c .GT. d) THEN
              y4 = d
              CALL PUSHCONTROL1B(0)
            ELSE
              y4 = c
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x8 .GT. y4) THEN
              x4 = y4
              CALL PUSHCONTROL1B(0)
            ELSE
              x4 = x8
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x4 .LT. 0.d0) THEN
              max3 = 0.d0
              CALL PUSHCONTROL1B(1)
            ELSE
              max3 = x4
              CALL PUSHCONTROL1B(0)
            END IF
            IF (a .LT. b) THEN
              x14 = b
              CALL PUSHCONTROL1B(0)
            ELSE
              x14 = a
              CALL PUSHCONTROL1B(1)
            END IF
            IF (c .LT. d) THEN
              y6 = d
              CALL PUSHCONTROL1B(0)
            ELSE
              y6 = c
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x14 .LT. y6) THEN
              x9 = y6
              CALL PUSHCONTROL1B(0)
            ELSE
              x9 = x14
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x9 .GT. 0.d0) THEN
              min1 = 0.d0
              CALL PUSHCONTROL1B(0)
            ELSE
              min1 = x9
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL8(dp1h)
            dp1h = max3 + min1
            a = 4.d0*d2m1 - d2
            b = 4.d0*d2 - d2m1
            c = d2m1
            d = d2
            IF (a .GT. b) THEN
              x10 = b
              CALL PUSHCONTROL1B(0)
            ELSE
              x10 = a
              CALL PUSHCONTROL1B(1)
            END IF
            IF (c .GT. d) THEN
              y5 = d
              CALL PUSHCONTROL1B(0)
            ELSE
              y5 = c
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x10 .GT. y5) THEN
              x5 = y5
              CALL PUSHCONTROL1B(0)
            ELSE
              x5 = x10
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x5 .LT. 0.d0) THEN
              max4 = 0.d0
              CALL PUSHCONTROL1B(1)
            ELSE
              max4 = x5
              CALL PUSHCONTROL1B(0)
            END IF
            IF (a .LT. b) THEN
              x15 = b
              CALL PUSHCONTROL1B(0)
            ELSE
              x15 = a
              CALL PUSHCONTROL1B(1)
            END IF
            IF (c .LT. d) THEN
              y7 = d
              CALL PUSHCONTROL1B(0)
            ELSE
              y7 = c
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x15 .LT. y7) THEN
              x11 = y7
              CALL PUSHCONTROL1B(0)
            ELSE
              x11 = x15
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x11 .GT. 0.d0) THEN
              min2 = 0.d0
              CALL PUSHCONTROL1B(0)
            ELSE
              min2 = x11
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL8(dm1h)
            dm1h = max4 + min2
C        qMD = 0.5*( ( Qi + Qip ) - dp1h )
C        qMD = 0.5D0*( ( 2.D0*Qi + DelIp ) - dp1h )
C        qUL = Qi + (1.D0-cfl)/(cfl+Eps)*DelI
C        qLC = Qi + 0.5D0*( 1.D0+dm1h/(DelI+Eps) )*(qUL-Qi)
C        PhiMD = 2.D0/(1.D0-cfl)*(qMD-Qi+Eps)/(DelIp+Eps)
C        PhiLC = 2.D0*rp1h_cfl*(qLC-Qi+Eps)/(qUL-Qi+Eps)
C--   simplify and avoid division by zero
            phimd = 1.d0/(1.d0-cfl)*(delip-dp1h)*recip_delip
            philc = rp1h_cfl*(1.d0+dm1h*recip_deli)
            IF (0.d0 .GT. phimd) THEN
              x6 = phimd
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
              x6 = 0.d0
            END IF
            IF (0.d0 .GT. 2.d0*rp1h_cfl) THEN
              x12 = 2.d0*rp1h_cfl
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
              x12 = 0.d0
            END IF
            IF (x12 .GT. philc) THEN
              y1 = philc
              CALL PUSHCONTROL1B(0)
            ELSE
              y1 = x12
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x6 .LT. y1) THEN
              phimin = y1
              CALL PUSHCONTROL1B(0)
            ELSE
              phimin = x6
              CALL PUSHCONTROL1B(1)
            END IF
            IF (2.d0/(1.d0-cfl) .LT. phimd) THEN
              x7 = phimd
              CALL PUSHCONTROL1B(0)
            ELSE
              x7 = 2.d0/(1.d0-cfl)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (0.d0 .LT. 2.d0*rp1h_cfl) THEN
              x13 = 2.d0*rp1h_cfl
              CALL PUSHCONTROL1B(0)
            ELSE
              x13 = 0.d0
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x13 .LT. philc) THEN
              y2 = philc
              CALL PUSHCONTROL1B(0)
            ELSE
              y2 = x13
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x7 .GT. y2) THEN
              phimax = y2
              CALL PUSHCONTROL1B(0)
            ELSE
              phimax = x7
              CALL PUSHCONTROL1B(1)
            END IF
            IF (phi .GT. phimax) THEN
              y3 = phimax
              CALL PUSHCONTROL1B(0)
            ELSE
              y3 = phi
              CALL PUSHCONTROL1B(1)
            END IF
            IF (phimin .LT. y3) THEN
              phi = y3
              CALL PUSHCONTROL1B(0)
            ELSE
              phi = phimin
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
        ENDDO
      ENDDO
      DO j=sny+oly-3,1-oly+4,-1
        DO i=snx+olx,1-olx,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            psi = phi*0.5d0*(1.d0-cfl)
            vtransb(i, j) = vtransb(i, j) + (qi+psi*delip)*vtb(i, j)
            tempb = vtrans(i, j)*vtb(i, j)
            vtb(i, j) = 0.D0
            qib = tempb
            psib = delip*tempb
            delipb = psi*tempb
            phib = (1.d0-cfl)*0.5d0*psib
            cflb = -(phi*0.5d0*psib)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y3b = phib
              phiminb = 0.D0
            ELSE
              phiminb = phib
              y3b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              phimaxb = y3b
              phib = 0.D0
            ELSE
              phib = y3b
              phimaxb = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y2b = phimaxb
              x7b = 0.D0
            ELSE
              x7b = phimaxb
              y2b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              philcb = y2b
              x13b = 0.D0
            ELSE
              x13b = y2b
              philcb = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              rp1h_cflb = 2.d0*x13b
            ELSE
              rp1h_cflb = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              phimdb = x7b
            ELSE
              cflb = cflb + 2.d0*x7b/(1.d0-cfl)**2
              phimdb = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y1b = phiminb
              x6b = 0.D0
            ELSE
              x6b = phiminb
              y1b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              philcb = philcb + y1b
              x12b = 0.D0
            ELSE
              x12b = y1b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) rp1h_cflb = rp1h_cflb + 2.d0*x12b
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) phimdb = phimdb + x6b
            rp1h_cflb = rp1h_cflb + (dm1h*recip_deli+1.d0)*philcb
            dm1hb = recip_deli*rp1h_cfl*philcb
            recip_delib = dm1h*rp1h_cfl*philcb
            temp = recip_delip/(-cfl+1.d0)
            delipb = delipb + temp*phimdb
            dp1hb = -(temp*phimdb)
            tempb = (delip-dp1h)*phimdb/(1.d0-cfl)
            recip_delipb = tempb
            cflb = cflb + temp*tempb
            CALL POPREAL8(dm1h)
            max4b = dm1hb
            min2b = dm1hb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              x11b = 0.D0
            ELSE
              x11b = min2b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y7b = x11b
              x15b = 0.D0
            ELSE
              x15b = x11b
              y7b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              db = y7b
              cb = 0.D0
            ELSE
              cb = y7b
              db = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              bb = x15b
              ab = 0.D0
            ELSE
              ab = x15b
              bb = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              x5b = max4b
            ELSE
              x5b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y5b = x5b
              x10b = 0.D0
            ELSE
              x10b = x5b
              y5b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              db = db + y5b
            ELSE
              cb = cb + y5b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              bb = bb + x10b
            ELSE
              ab = ab + x10b
            END IF
            d2b = db + 4.d0*bb - ab
            d2m1b = cb + 4.d0*ab - bb
            CALL POPREAL8(dp1h)
            max3b = dp1hb
            min1b = dp1hb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              x9b = 0.D0
            ELSE
              x9b = min1b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y6b = x9b
              x14b = 0.D0
            ELSE
              x14b = x9b
              y6b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              db = y6b
              cb = 0.D0
            ELSE
              cb = y6b
              db = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              bb = x14b
              ab = 0.D0
            ELSE
              ab = x14b
              bb = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              x4b = max3b
            ELSE
              x4b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y4b = x4b
              x8b = 0.D0
            ELSE
              x8b = x4b
              y4b = 0.D0
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              db = db + y4b
            ELSE
              cb = cb + y4b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              bb = bb + x8b
            ELSE
              ab = ab + x8b
            END IF
            d2p1b = db + 4.d0*bb - ab
            d2b = d2b + cb + 4.d0*ab - bb
            del2mb = d2m1b
            del2pb = d2p1b
            del2b = d2b
            CALL POPREAL8(rp1h_cfl)
            tempb = rp1h_cflb/(eps+cfl)
            rp1hb = tempb
            cflb = cflb - rp1h*tempb/(eps+cfl)
            CALL POPREAL8(rp1h)
            delib = recip_delip*rp1hb
            recip_delipb = recip_delipb + deli*rp1hb
            CALL POPREAL8(recip_deli)
            max2b = -(SIGN(1.d0, deli)*recip_delib/max2**2)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(max2)
              x3b = 0.D0
            ELSE
              CALL POPREAL8(max2)
              x3b = max2b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              delib = delib + x3b
            ELSE
              delib = delib - x3b
            END IF
            CALL POPREAL8(deli)
            qib = qib + mskim*delib
            qimb = -(mskim*delib)
            CALL POPREAL8(phi)
            recip_delipb = recip_delipb + phi*phib
            phib = recip_delip*phib
            CALL POPREAL8(recip_delip)
            max1b = -(SIGN(1.d0, delip)*recip_delipb/max1**2)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(max1)
              x2b = 0.D0
            ELSE
              CALL POPREAL8(max1)
              x2b = max1b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              delipb = delipb + x2b
            ELSE
              delipb = delipb - x2b
            END IF
            CALL POPREAL8(delip)
            facb = -(del6*phib)
            del6b = -(fac*phib)
            CALL POPREAL8(del6)
            del5mb = -del6b
            del4mb = -del5mb
            del3mmb = -del4mb
            del2mmb = -del3mmb
            delmmmb = -del2mmb
            tempb = mskim*mskimmm*mskimm*delmmmb
            qimmb = tempb
            qimmmb = -tempb
            CALL POPREAL8(fac)
            del5pb = del6b + fac*phib
            cflb = cflb + fac*facb/7.d0
            facb = (cfl+2.d0)*facb/7.d0 + del5p*phib
            CALL POPREAL8(del5p)
            del4pb = del5pb
            del3ppb = del4pb
            del2ppb = del3ppb
            CALL POPREAL8(fac)
            del4b = del5mb + fac*phib - del5pb
            del3mb = del4mb - del4b
            del2mb = del2mb + del3mmb - del3mb
            delmmb = del2mmb - del2mb
            cflb = cflb + fac*facb/6.d0
            facb = (cfl+2.d0)*facb/6.d0 + del4*phib
            CALL POPREAL8(del4)
            tempb = mskimm*mskim*delmmb
            qimmb = qimmb - tempb
            CALL POPREAL8(fac)
            del3pb = del4b - del4pb + fac*phib
            del2pb = del2pb + del3pb - del3ppb
            delppb = del2ppb + del2pb
            cflb = cflb + fac*facb/5.d0
            facb = (cfl-3.d0)*facb/5.d0 + del3p*phib
            CALL POPREAL8(del3p)
            CALL POPREAL8(fac)
            del2b = del2b + del3mb - del3pb - fac*phib
            delmb = del2mb - del2b
            qimb = qimb + tempb - mskim*delmb
            tempb = mskip*mski*delppb
            qippb = tempb
            cflb = cflb + fac*facb/4.d0
            facb = (cfl-2.d0)*facb/4.d0 - del2*phib
            CALL POPREAL8(del2)
            CALL POPREAL8(fac)
            delpb = del2b - del2ppb - del2pb + fac*phib
            qipb = mski*delipb + mski*delpb - tempb
            qib = qib + mskim*delmb - mski*delipb - mski*delpb
            cflb = cflb + fac*facb/3.d0
            CALL POPREAL8(phi)
            CALL POPREAL8(fac)
          ELSE
            vtb(i, j) = 0.D0
            qib = 0.D0
            cflb = 0.D0
            qimb = 0.D0
            qipb = 0.D0
            qimmmb = 0.D0
            qippb = 0.D0
            qimmb = 0.D0
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(mskimmm)
            CALL POPREAL8(mskimm)
            CALL POPREAL8(mskim)
            CALL POPREAL8(mski)
            CALL POPREAL8(mskip)
            qb(i, j-4) = qb(i, j-4) + qimmmb
            qb(i, j-3) = qb(i, j-3) + qimmb
            qb(i, j-2) = qb(i, j-2) + qimb
            CALL POPREAL8(qi)
            qb(i, j-1) = qb(i, j-1) + qib
            qb(i, j) = qb(i, j) + qipb
            qb(i, j+1) = qb(i, j+1) + qippb
          ELSE IF (branch .EQ. 1) THEN
            CALL POPREAL8(mskimmm)
            CALL POPREAL8(mskimm)
            CALL POPREAL8(mskim)
            CALL POPREAL8(mski)
            CALL POPREAL8(mskip)
            qb(i, j+3) = qb(i, j+3) + qimmmb
            qb(i, j+2) = qb(i, j+2) + qimmb
            qb(i, j+1) = qb(i, j+1) + qimb
            CALL POPREAL8(qi)
            qb(i, j) = qb(i, j) + qib
            qb(i, j-1) = qb(i, j-1) + qipb
            qb(i, j-2) = qb(i, j-2) + qippb
          ELSE
            CALL POPREAL8(mskimmm)
            CALL POPREAL8(mskimm)
            CALL POPREAL8(mskim)
            CALL POPREAL8(mski)
            CALL POPREAL8(mskip)
            CALL POPREAL8(qi)
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            vlocb = 0.D0
          ELSE
            IF (branch .EQ. 1) THEN
              x1b = -cflb
            ELSE
              x1b = cflb
            END IF
            vlocb = deltatloc*recip_dyc(i, j, bi, bj)*x1b
            cflb = 0.D0
          END IF
          CALL POPREAL8(cfl)
          vlocb = vlocb + cflb
          vfldb(i, j) = vfldb(i, j) + vlocb
        ENDDO
      ENDDO
      DO i=snx+olx,1-olx,-1
        vtb(i, sny+oly) = 0.D0
        vtb(i, sny+oly-1) = 0.D0
        vtb(i, sny+oly-2) = 0.D0
        vtb(i, 4-oly) = 0.D0
        vtb(i, 3-oly) = 0.D0
        vtb(i, 2-oly) = 0.D0
        vtb(i, 1-oly) = 0.D0
      ENDDO
      END

